# ======================================================================
# Docker Compose para uma stack simples:
# - postgres (banco)
# - app1 e app2 (duas instâncias da mesma aplicação Node.js)
# - nginx (balanceador/reverso)
#
# DICAS RÁPIDAS DE USO
#   Subir:    docker compose up -d --build
#   Subir (respeitando 'deploy.resources.*' sem Swarm): docker compose --compatibility up -d --build
#   Descer:   docker compose down -v     # '-v' remove o volume 'pgdata' (DADOS DO BANCO SERÃO PERDIDOS)
#
# NOTA SOBRE LIMITES DE RECURSOS:
#   O bloco 'deploy.resources.limits' só é aplicado nativamente no Docker Swarm.
#   Em Docker Compose "puro", use a flag '--compatibility' para que o Compose
#   traduza esses limites para 'cpus' e 'mem_limit' suportados pelo engine local.
# ======================================================================

services:

  # --------------------------------------------------------------------
  # Serviço: Banco de Dados PostgreSQL
  # - Imagem oficial, versão 15 (versão estável e amplamente suportada)
  # - Persiste dados em volume nomeado 'pgdata'
  # - Executa script de init (DDL/DML) em ./sql/init.sql na primeira subida
  # - Healthcheck garante que o serviço esteja pronto antes dos apps
  # - Porta 5433 no host para não colidir com instalações locais (5432)
  # --------------------------------------------------------------------
  postgres:
    image: postgres:15                  # Pin de versão evita surpresas (vs 'latest')
    container_name: postgres
    restart: always                     # Reinicia automaticamente em falhas ou reboot

    # Variáveis de ambiente usadas pelo entrypoint do Postgres.
    # POSTGRES_DB cria o banco inicial; POSTGRES_USER/PASSWORD criam superuser/senha.
    # ATENÇÃO: POSTGRES_HOST_AUTH_METHOD=trust desabilita autenticação local,
    #          útil para DEV/TESTE, inseguro em produção. Mantenha apenas em ambientes controlados.
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: postgres_api_db
      POSTGRES_HOST_AUTH_METHOD: trust  # DEV ONLY: remova em prod e use autenticação padrão (md5/scram)

    # Volumes:
    # - 'pgdata' guarda os arquivos do cluster e sobrevive a 'docker compose down'
    # - init.sql é montado como somente leitura (':ro') e roda só se o cluster for novo
    volumes:
      - pgdata:/var/lib/postgresql/data
      - ./sql/init.sql:/docker-entrypoint-initdb.d/init.sql:ro

    # Limites de CPU e memória:
    # - Em Swarm: aplicados diretamente
    # - Em Compose local: use '--compatibility' para converter
    deploy:
      resources:
        limits:
          cpus: "0.5"                   # ~80% de 1 CPU lógico
          memory: "250MB"

    # Porta do host 5433 -> 5432 do container (evita conflito com Postgres local)
    ports:
      - "5433:5432"

    # Healthcheck: 'pg_isready' retorna sucesso quando o servidor aceita conexões
    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U postgres -d postgres_api_db" ]
      interval: 10s                     # faz o teste a cada 10s
      timeout: 5s
      retries: 5
      start_period: 30s                 # tempo extra para o Postgres iniciar antes de começar a cobrar retries

  # --------------------------------------------------------------------
  # Serviço: app1 (Node.js)
  # - Primeira instância da aplicação, para paralelizar atendimentos
  # - Expõe a porta 3001 internamente (Nginx acessa via rede de serviço)
  # - Depende do Postgres estar saudável (healthcheck OK)
  # --------------------------------------------------------------------
  app1:
    build: ./app                        # Dockerfile em ./app (gera imagem da aplicação)
    container_name: app1

    # Variáveis de ambiente padrão para configurar HTTP e conexão com o banco
    environment:
      PORT: 3001
      DB_HOST: postgres                 # Usa o nome do serviço como hostname (DNS interno do Compose)
      DB_PORT: 5432
      DB_USER: postgres
      DB_PASSWORD: postgres
      DB_DATABASE: postgres_api_db
      HOSTNAME: app1                    # Útil para logs/observabilidade

    # 'expose' publica a porta apenas na rede interna do Compose (NÃO no host)
    # Nginx enxergará 'app1:3001' via DNS interno; nada abre no host
    expose:
      - "3001"

    # 'depends_on' com condição de saúde: só considera "ok" após healthcheck do Postgres.
    # Observação: o suporte a 'condition: service_healthy' requer Docker Compose moderno.
    depends_on:
      postgres:
        condition: service_healthy

    deploy:
      resources:
        limits:
          cpus: "0.3"
          memory: "100MB"

    restart: unless-stopped             # Reinicia salvo se explicitamente parado

  # --------------------------------------------------------------------
  # Serviço: app2 (Node.js)
  # - Segunda instância da aplicação (replica app1) para balanceamento
  # - Porta interna 3002
  # --------------------------------------------------------------------
  app2:
    build: ./app
    container_name: app2

    environment:
      PORT: 3002
      DB_HOST: postgres
      DB_PORT: 5432
      DB_USER: postgres
      DB_PASSWORD: postgres
      DB_DATABASE: postgres_api_db
      HOSTNAME: app2

    expose:
      - "3002"

    depends_on:
      postgres:
        condition: service_healthy

    deploy:
      resources:
        limits:
          cpus: "0.3"
          memory: "100MB"

    restart: unless-stopped

  # --------------------------------------------------------------------
  # Serviço: nginx (reverse proxy / balanceador)
  # - Recebe tráfego no host:9999 e distribui para app1 e app2
  # - Requer um nginx.conf que:
  #     * escute na porta 9999;
  #     * aponte 'upstream' para 'app1:3001' e 'app2:3002';
  #     * faça proxy_pass para o upstream.
  # --------------------------------------------------------------------
  nginx:
    image: nginx:latest                 # Em produção, prefira fixar versão (ex.: nginx:1.26-alpine)
    container_name: nginx

    # Mapeamento de porta do host -> container
    # Garante acesso externo via http://localhost:9999
    ports:
      - "9999:9999"

    # Monta a configuração customizada do Nginx sobre /etc/nginx/nginx.conf
    # ATENÇÃO: o arquivo deve existir e conter 'listen 9999;' no 'server { ... }'
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf

    # Sobe depois que as apps estiverem "disponíveis" (do ponto de vista do Compose)
    # Observação: isso NÃO garante que o HTTP da app já responda 200; apenas ordena a criação.
    depends_on:
      - app1
      - app2

    deploy:
      resources:
        limits:
          cpus: "0.4"
          memory: "100MB"

    restart: unless-stopped

# ----------------------------------------------------------------------
# Volumes nomeados
# - 'pgdata': armazena os dados do Postgres
#   Para remover dados completamente: 'docker volume rm <projeto>_pgdata'
# ----------------------------------------------------------------------
volumes:
  pgdata:
